# FlowDoChat SwiftUI コーディング規約 (Implementation Guidelines)

これからの実装（SwiftUI化）において、**「途中で破綻しない」** ための技術的な鉄の掟をここに定める。
AIがコードを書く際、迷ったらこのルールに立ち返ること。

---

## 1. ディレクトリ構造 (Feature-First)

機能ごとにフォルダをまとめる構成にする。
「全部のViewが `Views` フォルダにある」ような古い構成は禁止。

```text
FlowDoChat/
├── App/
│   ├── FlowDoApp.swift
│   └── ContentView.swift (Root Routing)
├── Features/          <-- 機能単位
│   ├── Home/
│   │   ├── Views/ (HomeView.swift, Components/...)
│   │   └── ViewModels/ (HomeViewModel.swift)
│   ├── Memories/
│   ├── Onboarding/
│   └── Paywall/
├── Shared/            <-- 全体共通
│   ├── Components/ (PrimaryButton, GlassCard, etc.)
│   ├── Styles/ (Color+Ext, Font+Ext, Modifiers)
│   └── Extensions/
└── Core/              <-- ロジックの芯
    ├── Models/ (TaskItem.swift, UserProfile.swift)
    ├── Services/ (AIService.swift, StorageService.swift)
    └── Utilities/
```

---

## 2. アーキテクチャ (Kida-Style MVVM & Navigation)

### A. Navigation: 型安全Router + 単一Navigator
`NavigationLink(destination: ...)` の散乱は禁止。
`enum Route` で遷移先を全定義し、`NavigationStack(path:)` で管理する。
画面遷移は `EnvironmentObject` の Navigator 経由で行うこと（`navigator.push(.detail)`）。

### B. View構造: List禁止令
`List` や `LazyVStack` は、FlowDoChatのようなリッチなUI（重ね合わせ、アニメーション多用）ではバグの温床になる。
**`ScrollView + VStack + ForEach`** の構成で完全に制御する。
（パフォーマンスが心配な場合のみ `LazyVStack` を検討するが、基本はVStackで組む）

### C. 状態管理: 実戦的アプローチ
厳密すぎるMVVM（Viewに一切ロジックなし）よりも、**「Viewが等身大の状態を持つ」** ことを許容する。
*   画面固有のUI状態（スクロール位置、アニメーションフラグ）は、View内の `@State` と `private func` で完結させる。
*   ドメインデータ（タスクなど）のみ ViewModel / Service に逃がす。
*   **非同期処理:** `.task { ... }` を使い、副作用（データフェッチ）のタイミングをViewライフサイクルに合わせる。

---

## 3. デザインの実装 (Vibe Translation)

HTML/Tailwindで設計した「空気感（Vibe）」を再現するためのルール。

### A. カラーは全て「意味」で定義する (Semantic Colors)
色のHex値をViewに直接書かない。`Color+Extension.swift` に定義すること。
特に「Context Aura」の3色は命。

```swift
extension Color { // let 変数Color と指定する必要がある。Colorは語尾につける必要がある。
    static let contextFocusColor = Color("ContextFocus")   // Red/Orange
    static let contextRoutineColor = Color("ContextRoutine") // Blue/Cyan
    static let contextCareColor = Color("ContextCare")     // Yellow/Gold
    static let glassBackgroundColor = Color.white.opacity(0.1)
}
```

### B. Glassmorphismの共通化
`background(.ultraThinMaterial)` だけでは足りない。
HTMLで検証した「影」「ボーダー」「透明度」をセットにした `ViewModifier` を作ること。
ボタンの押し心地（Scale Effect）も `PrimitiveButtonStyle` で統一実装する。

```swift
struct GlassCard: ViewModifier {
    func body(content: Content) -> some View {
        content
            .background(.ultraThinMaterial)
            .overlay(RoundedRectangle(cornerRadius: 20).stroke(.white.opacity(0.2), lineWidth: 1))
            .shadow(color: .black.opacity(0.1), radius: 10, x: 0, y: 5)
    }
}
```

---

## 4. コンポーネント設計 (Component Isolation)

### A. View分割の基準
「再利用性」よりも「可読性」を重視する。
無理に別ファイルに切り出さず、**「同一ファイル内の private struct / extension」** として定義してよい。
ファイルを行ったり来たりするコストを下げる。

### B. GeometryReaderの乱用禁止
サイズ取得は可能な限り `frame(maxWidth: .infinity)` や `Preference` で行う。
GeometryReaderは「アニメーション座標の計算」など、どうしても必要な時だけ **局所的に** 使う。


---

## 4. データフロー (Sources of Truth)

### A. タスクデータの管理
`StorageService` (Singleton) がマスターデータを持つ。
各ViewModelはそこからデータを受け取る、または購読する形にする。
アプリを再起動しても消えないよう、操作のたびに `save()` が走るように組むこと。

### B. AIサービスの利用
`AIService.shared.suggestTasks(...)` のように、どこからでも呼べるシングルトンとして切り出す。
Viewの中に `URLSession` のコードを書いたら即リファクタリング対象とする。

---

## 5. AIへの指示出し (Prompt Engineering in Code)

`Core/Services/PromptFactory.swift` を作り、システムプロンプトの生成ロジックを一箇所に集約する。
「コードの中に長い文字列リテラル」を散乱させないこと。

```swift
// ✅ Good
let systemPrompt = PromptFactory.makeSystemPrompt(for: userProfile)
```

以上。
